### AdventofCode
Solutions to the Advent of Code puzzles with some incredibly overkill generative scripts. It's the holidays, have fun with it.

https://adventofcode.com

While in root directory run the following command to automatically:
1. Create a new directory with today's day nested under the current year
2. Create an input.txt file to quickly copy/paste the advent data
3. Create 2 solution.py files (1 for each part) with starter code to read in the txt file and start smashing away at a solution

Finally, if you want to overwrite a directory add '--overwrite' and all files will be replaced.


``
python create_new_day.py
``


Now it's time to update the readme with all your solutions. Because if displayed code isnt pretty than I don't know what is.
Anyways, doing this is easy, define a 'readmetemplate.md' in the root folder and run the following script:

``python update_readme_stats.py``

This will automatically run your solutions, time it and display each solution for each day in the readme.

Bonkers.

<hr>



#### Jump to solution 

 [![2025 Day 4 Badge](https://img.shields.io/badge/2025%20Day%204-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-4) 
 [![2025 Day 3 Badge](https://img.shields.io/badge/2025%20Day%203-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-3) 
 [![2025 Day 2 Badge](https://img.shields.io/badge/2025%20Day%202-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-2) 
 [![2025 Day 1 Badge](https://img.shields.io/badge/2025%20Day%201-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-1) 
 

 [![2024 Day 11 Badge](https://img.shields.io/badge/2024%20Day%2011-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-11) 
 [![2024 Day 10 Badge](https://img.shields.io/badge/2024%20Day%2010-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-10) 
 [![2024 Day 9 Badge](https://img.shields.io/badge/2024%20Day%209-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-9) 
 [![2024 Day 8 Badge](https://img.shields.io/badge/2024%20Day%208-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-8) 
 [![2024 Day 7 Badge](https://img.shields.io/badge/2024%20Day%207-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-7) 
 [![2024 Day 6 Badge](https://img.shields.io/badge/2024%20Day%206-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-6) 
 [![2024 Day 5 Badge](https://img.shields.io/badge/2024%20Day%205-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-5) 
 [![2024 Day 4 Badge](https://img.shields.io/badge/2024%20Day%204-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-4) 
 [![2024 Day 3 Badge](https://img.shields.io/badge/2024%20Day%203-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-3) 
 [![2024 Day 2 Badge](https://img.shields.io/badge/2024%20Day%202-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-2) 
 [![2024 Day 1 Badge](https://img.shields.io/badge/2024%20Day%201-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-1) 
 

 [![2023 Day 11 Badge](https://img.shields.io/badge/2023%20Day%2011-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-11) 
 [![2023 Day 9 Badge](https://img.shields.io/badge/2023%20Day%209-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-9) 
 [![2023 Day 8 Badge](https://img.shields.io/badge/2023%20Day%208-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-8) 
 [![2023 Day 7 Badge](https://img.shields.io/badge/2023%20Day%207-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-7) 
 [![2023 Day 6 Badge](https://img.shields.io/badge/2023%20Day%206-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-6) 
 [![2023 Day 5 Badge](https://img.shields.io/badge/2023%20Day%205-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-5) 
 [![2023 Day 4 Badge](https://img.shields.io/badge/2023%20Day%204-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-4-1) 
 [![2023 Day 3 Badge](https://img.shields.io/badge/2023%20Day%203-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-3-1) 
 [![2023 Day 2 Badge](https://img.shields.io/badge/2023%20Day%202-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-2-1) 
 [![2023 Day 1 Badge](https://img.shields.io/badge/2023%20Day%201-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-1-1) 
 

 [![2022 Day 11 Badge](https://img.shields.io/badge/2022%20Day%2011-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-11-1) 
 [![2022 Day 10 Badge](https://img.shields.io/badge/2022%20Day%2010-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-10) 
 [![2022 Day 9 Badge](https://img.shields.io/badge/2022%20Day%209-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-9-1) 
 [![2022 Day 8 Badge](https://img.shields.io/badge/2022%20Day%208-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-8-1) 
 [![2022 Day 7 Badge](https://img.shields.io/badge/2022%20Day%207-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-7-1) 
 [![2022 Day 6 Badge](https://img.shields.io/badge/2022%20Day%206-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-6-1) 
 [![2022 Day 5 Badge](https://img.shields.io/badge/2022%20Day%205-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-5-1) 
 [![2022 Day 4 Badge](https://img.shields.io/badge/2022%20Day%204-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-4-2) 
 [![2022 Day 3 Badge](https://img.shields.io/badge/2022%20Day%203-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-3-2) 
 [![2022 Day 2 Badge](https://img.shields.io/badge/2022%20Day%202-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-2-2) 
 [![2022 Day 1 Badge](https://img.shields.io/badge/2022%20Day%201-none?logo=python&logoColor=f43f5e&color=065f46&labelColor=white&)](#-day-1-2) 


### Year 2025

### üéÑ Day 4

#### Day 4 Solution part 1

- **Answer**: 1505
- **Timing**: 0.01735091209411621

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 4 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()
	# Solving
	sol = 0
	directions = [
		(0, 1),  # Right
		(0, -1),  # Left
		(1, 0),  # Down
		(-1, 0),  # Up
		(1, 1),  # Down-right diagonal
		(-1, -1),  # Up-left diagonal
		(1, -1),  # Down-left diagonal
		(-1, 1),  # Up-right diagonal
	]
	max_paper_in_area = 4
	roll_char = "@"
	for row in range(len(entries)):
		for col in range(len(entries[row])):
			candidate = entries[row][col]
			count = 0
			if candidate != roll_char: continue
			for dr, dc in directions:
				nr, nc = row + dr, col + dc
				if 0 <= nr < len(entries) and 0 <= nc < len(entries[nr]):
					count += entries[nr][nc] == roll_char
			sol += count < max_paper_in_area
	return sol
```
</details>

#### Day 4 Solution part 2

- **Answer**: 9182
- **Timing**: 0.4265408515930176

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 4 part 2
Solved by doing some magic
"""
import time
import sys

def remove_from_grid(grid: list[str]):
	directions = [
		(0, 1),  # Right
		(0, -1),  # Left
		(1, 0),  # Down
		(-1, 0),  # Up
		(1, 1),  # Down-right diagonal
		(-1, -1),  # Up-left diagonal
		(1, -1),  # Down-left diagonal
		(-1, 1),  # Up-right diagonal
	]
	roll_char = "@"
	max_paper_in_area = 4
	new_grid = grid.copy()
	removed_count = 0
	for row in range(len(grid)):
		for col in range(len(grid[row])):
			candidate = grid[row][col]
			count = 0
			if candidate != roll_char: continue
			for dr, dc in directions:
				nr, nc = row + dr, col + dc
				if 0 <= nr < len(grid) and 0 <= nc < len(grid[nr]):
					surrounding_candidate = grid[nr][nc]
					count += surrounding_candidate == roll_char
			can_remove = count < max_paper_in_area
			if can_remove:
				new_grid[row] = new_grid[row][:col] + '.' + new_grid[row][col + 1:]
				removed_count += 1
	return new_grid, removed_count


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()
	# Solving
	sol = 0
	can_continue = True
	while can_continue:
		entries, removed = remove_from_grid(entries)
		sol += removed
		can_continue = removed > 0
	return sol
```
</details>

<hr>

### ü¶å Day 3

#### Day 3 Solution part 1

- **Answer**: 17376
- **Timing**: 0.17606210708618164

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 3 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()
	sol = 0
	for i, bank in enumerate(entries):
		bank_max = 0
		for j in range(len(str(bank))):
			for ij in range(len(bank[j + 1:])):
				bank_max = max(bank_max, int(f"{bank[j]}{bank[ij + j + 1]}"))
		sol += bank_max
	return sol
```
</details>

#### Day 3 Solution part 2

- **Answer**: 172119830406258
- **Timing**: 0.0047910213470458984

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 3 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read().strip().splitlines()

	sol = 0
	batteries_needed = 12
	for bank in entries:
		stack = []
		remaining = len(bank)
		for digit in bank:
			d = int(digit)
			while stack and stack[-1] < d and len(stack) - 1 + remaining >= batteries_needed:
				stack.pop()
			if len(stack) < batteries_needed:
				stack.append(d)
			remaining -= 1
		sol += int("".join(map(str, stack)))
	return sol
```
</details>

<hr>

### üéÅ Day 2

#### Day 2 Solution part 1

- **Answer**: 24157613387
- **Timing**: 0.46494102478027344

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 2 part 1
Solved by doing some magic
"""
import time
import sys


def is_invalid(s: str):
    l = len(s)
    if l % 2 != 0:
        return False
    half = l // 2
    return s[:half] == s[half:]


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    ranges = [(map(int, part.split("-"))) for part in entries.split(",")]

    sol = 0

    for first, last in ranges:
        for candidate in range(first, last + 1):
            if is_invalid(str(candidate)):
                sol += candidate
    return sol
```
</details>

#### Day 2 Solution part 2

- **Answer**: 33832678380
- **Timing**: 1.1601111888885498

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 2 part 2
Solved by doing some magic
"""
import time
import sys


def is_invalid(s: str):
    l = len(s)

    for k in range(1, l // 2 + 1):
        if l % k == 0:
            sub = s[:k]
            if sub * (l // k) == s:
                return True
    return False


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    ranges = [(map(int, part.split("-"))) for part in entries.split(",")]

    sol = 0

    for first, last in ranges:
        for candidate in range(first, last + 1):
            if is_invalid(str(candidate)):
                sol += candidate
    return sol
```
</details>

<hr>

### ‚õÑ Day 1

#### Day 1 Solution part 1

- **Answer**: 1145
- **Timing**: 0.025949954986572266

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 1 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# tupes ma goops
	entries = [(line[0], int(line[1:])) for line in entries.splitlines()]
	# Solving
	dial = 50
	sol = 0
	for i, (direction, distance) in enumerate(entries):
		for j in range(distance):
			if direction == 'L':
				dial -= 1
				if dial < 0:
					dial = 99
			else:
				dial += 1
				if dial > 99:
					dial = 0
		sol += dial == 0
	return sol
```
</details>

#### Day 1 Solution part 2

- **Answer**: 6561
- **Timing**: 0.03969621658325195

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2025 day 1 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# tupes ma goops
	entries = [(line[0], int(line[1:])) for line in entries.splitlines()]
	# Solving
	dial = 50
	sol = 0
	for i, (direction, distance) in enumerate(entries):
		# my sloppy range means p2 is easy. yay.
		for j in range(distance):
			if direction == 'L':
				dial -= 1
				if dial < 0:
					dial = 99
			else:
				dial += 1
				if dial > 99:
					dial = 0
			sol += dial == 0
	return sol
```
</details>

<hr>

### Year 2024

### üîî Day 11

#### Day 11 Solution part 1

- **Answer**: 189092
- **Timing**: 0.001811981201171875

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 11 part 1
Solved by doing some magic
"""
import time
import sys
from collections import Counter


def split_stone(stone):
    half = len(str(stone)) // 2
    l, r = divmod(stone, 10 ** half)
    if r % 10 == 0:
        r //= 10
        r *= 10
    return l, r


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = [int(num) for num in file.read().strip().split()]

    stones = Counter(entries)

    for _ in range(25):
        new_stones = Counter()
        for stone, count in stones.items():
            if stone == 0:
                new_stones[1] += count
            elif len(str(stone)) % 2 == 0:
                left, right = split_stone(stone)
                new_stones[left] += count
                new_stones[right] += count
            else:
                new_stones[stone * 2024] += count
        stones = new_stones

    return sum(stones.values())
```
</details>

#### Day 11 Solution part 2

- **Answer**: 224869647102559
- **Timing**: 0.06890511512756348

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 11 part 2
Solved by doing some magic
"""
import time
import sys
from collections import Counter


def split_stone(stone):
    half = len(str(stone)) // 2
    l, r = divmod(stone, 10 ** half)
    if r % 10 == 0:
        r //= 10
        r *= 10
    return l, r


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = [int(num) for num in file.read().strip().split()]

    stones = Counter(entries)

    for _ in range(75):
        new_stones = Counter()
        for stone, count in stones.items():
            if stone == 0:
                new_stones[1] += count
            elif len(str(stone)) % 2 == 0:
                left, right = split_stone(stone)
                new_stones[left] += count
                new_stones[right] += count
            else:
                new_stones[stone * 2024] += count
        stones = new_stones

    return sum(stones.values())
```
</details>

<hr>

### ‚õ∏Ô∏è Day 10

#### Day 10 Solution part 1

- **Answer**: 688
- **Timing**: 0.007177829742431641

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 10 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()
	num_rows = len(entries)
	num_cols = len(entries[0])
	trail_heads = []

	def is_inbounds(row, col) -> bool:
		return (0 <= row < num_rows) and (0 <= col < num_cols)

	# first find trailheads to start with.
	for row in range(len(entries)):
		entries[row] = [int(char) for char in entries[row]]
		for col in range(len(entries[row])):
			if entries[row][col] == 0:
				trail_heads.append((row, col))

	def look_around(pos):
		# this finds new positions in the grid that that are valid to continue down, these new positions get added
		# to the queue to explore.
		row, col = pos
		target_height = entries[row][col] + 1
		positions = []
		for d_r, d_c in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
			new_row, new_col = row + d_r, col + d_c
			if is_inbounds(new_row, new_col) and entries[new_row][new_col] == target_height:
				positions.append((new_row, new_col))
		return positions
	sol = 0
	for trail in trail_heads:
		paths = set()
		coords = [trail]
		while coords:
			pos = coords.pop()
			new_positions = look_around(pos)
			for (x, y) in new_positions:
				coords.append((x, y))
				if entries[x][y] == 9:
					paths.add((x, y))
		sol += len(paths)
	return sol
```
</details>

#### Day 10 Solution part 2

- **Answer**: 1459
- **Timing**: 0.0072519779205322266

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 10 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()
	num_rows = len(entries)
	num_cols = len(entries[0])
	trail_heads = []

	def is_inbounds(row, col) -> bool:
		return (0 <= row < num_rows) and (0 <= col < num_cols)

	# first find trailheads to start with.
	for row in range(len(entries)):
		entries[row] = [int(char) for char in entries[row]]
		for col in range(len(entries[row])):
			if entries[row][col] == 0:
				trail_heads.append((row, col))

	def look_around(pos):
		# this finds new positions in the grid that that are valid to continue down, these new positions get added
		# to the queue to explore.
		row, col = pos
		target_height = entries[row][col] + 1
		positions = []
		for d_r, d_c in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
			new_row, new_col = row + d_r, col + d_c
			if is_inbounds(new_row, new_col) and entries[new_row][new_col] == target_height:
				positions.append((new_row, new_col))
		return positions
	sol = 0
	for trail in trail_heads:
		paths = []
		coords = [trail]
		while coords:
			pos = coords.pop()
			new_positions = look_around(pos)
			for (x, y) in new_positions:
				coords.append((x, y))
				if entries[x][y] == 9:
					paths.append((x, y))
		sol += len(paths)
	return sol
```
</details>

<hr>

### üç™ Day 9

#### Day 9 Solution part 1

- **Answer**: 6262891638328
- **Timing**: 0.011310100555419922

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 9 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read()
	entries = iter(entries.strip())

	entries = [int(num) for num in entries]

	block_id = 0
	strip = []
	is_block = True
	for i in range(len(entries)):
		if is_block:
			strip.extend([block_id] * entries[i])
			block_id += 1
		else:
			strip.extend([None] * entries[i])

		is_block = not is_block

	free_space = strip.index(None)
	for i in reversed(range(0, len(strip))):
		if strip[i] is not None:
			strip[free_space] = strip[i]
			strip[i] = None
			while strip[free_space] is not None:
				free_space += 1
			if i - free_space <= 1:
				break

	return sum(val * itx for (itx, val) in enumerate(strip) if val is not None)
```
</details>

#### Day 9 Solution part 2

- **Answer**: 6287317016845
- **Timing**: 0.15664100646972656

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 9 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read()
	entries = iter(entries.strip())
	entries = [int(num) for num in entries]
	block_id = 0
	strip = []
	gaps = []
	blocks = []
	is_block = True
	for i in range(len(entries)):
		if is_block:
			blocks.append((len(strip), block_id, entries[i]))
			strip.extend([block_id] * entries[i])
			block_id += 1
		else:
			gaps.append((entries[i], len(strip)))
			strip.extend([None] * entries[i])

		is_block = not is_block

	for block in reversed(blocks):
		position, b_id, length = block
		for itx, (gap_length, gap_position) in enumerate(gaps):
			if gap_position > position:
				break

			if gap_length >= length:
				for l in range(length):
					strip[position + l] = None
					strip[gap_position + l] = b_id

				diff = gap_length - length
				if diff > 0:
					gaps[itx] = (diff, gap_position + length)
				else:
					gaps.pop(itx)
				break
	return sum(val * itx for (itx, val) in enumerate(strip) if val is not None)
```
</details>

<hr>

### üåü Day 8

#### Day 8 Solution part 1

- **Answer**: 280
- **Timing**: 0.0005071163177490234

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 8 part 1
Solved by doing some magic
"""
import itertools
import time
import sys
from collections import defaultdict


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = [list(e) for e in entries.splitlines()]
	num_rows, num_cols = len(entries), len(entries[0])
	locations = set()

	# get freq -> locations mapping.
	frequency_to_locations = defaultdict(list)

	for row in range(num_rows):
		for col in range(num_cols):
			if entries[row][col] != ".":
				freq = entries[row][col]
				frequency_to_locations[freq].append((col, row))

	def is_inbounds(row, col) -> bool:
		return (0 <= row < num_rows) and (0 <= col < num_cols)

	# Determine possible antinode locations for each frequency
	for freq, positions in frequency_to_locations.items():
		for (col1, row1), (col2, row2) in itertools.combinations(positions, 2):

			delta_row, delta_col = row2 - row1, col2 - col1
			antinode_row, antinode_col = row2 + delta_row, col2 + delta_col

			if is_inbounds(antinode_row, antinode_col):
				locations.add((antinode_row, antinode_col))
			# Check the second potential antinode location
			antinode_row, antinode_col = row1 - delta_row, col1 - delta_col
			if is_inbounds(antinode_row, antinode_col):
				locations.add((antinode_row, antinode_col))
	return len(locations)
```
</details>

#### Day 8 Solution part 2

- **Answer**: 958
- **Timing**: 0.0007419586181640625

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 8 part 2
Solved by doing some magic
"""
import itertools
import time
import sys
from collections import defaultdict


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    entries = [list(e) for e in entries.splitlines()]
    num_rows, num_cols = len(entries), len(entries[0])
    locations = set()

    frequency_to_locations = defaultdict(list)

    for row_index in range(num_rows):
        for col_index in range(num_cols):
            if entries[row_index][col_index] != ".":
                frequency = entries[row_index][col_index]
                frequency_to_locations[frequency].append((col_index, row_index))

    def is_inbounds(row, col) -> bool:
        return (0 <= row < num_rows) and (0 <= col < num_cols)

    for freq, positions in frequency_to_locations.items():
        for (col1, row1), (col2, row2) in itertools.combinations(positions, 2):
            delta_row, delta_col = row2 - row1, col2 - col1

            # Traverse in the forward direction
            current_row, current_col = row2, col2

            while is_inbounds(current_row, current_col):
                locations.add((current_row, current_col))
                current_row += delta_row
                current_col += delta_col

            # Traverse in the backward direction
            current_row, current_col = row1, col1
            while is_inbounds(current_row, current_col):
                locations.add((current_row, current_col))
                current_row -= delta_row
                current_col -= delta_col
    return len(locations)
```
</details>

<hr>

### ‚ùÑÔ∏è Day 7

#### Day 7 Solution part 1

- **Answer**: 2941973819040
- **Timing**: 0.4605898857116699

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 7 part 1
Solved by doing some magic
"""
import itertools
import time
import sys


def evaluate_left_to_right(expression):
    tokens = expression.split()
    result = int(tokens[0])
    for i in range(1, len(tokens), 2):
        operator = tokens[i]
        number = int(tokens[i + 1])
        if operator == '+':
            result += number
        elif operator == '*':
            result *= number
    return result


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	entries = entries.splitlines()

	sol = 0
	for line in entries:
		test_val, nums = line.split(":")
		nums = nums.split()
		for ops in itertools.product(['+', '*'], repeat=len(nums) - 1):
			# this creates a string like '1 + 3 * 6' where all possible operators are tried
			# to pass into the eval function.
			expression = " ".join(num + " " + op for num, op in zip(nums, ops + ('',)))
			result = evaluate_left_to_right(expression)
			if int(result) == int(test_val):
				sol += int(test_val)
				break
	return sol
```
</details>

#### Day 7 Solution part 2

- **Answer**: 249943041417600
- **Timing**: 23.446258068084717

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 7 part 2
Solved by doing some magic
"""
import itertools
import time
import sys


def evaluate_left_to_right(expression):
    tokens = expression.split()
    result = int(tokens[0])

    for i in range(1, len(tokens), 2):
        operator = tokens[i]
        number = int(tokens[i + 1])
        if operator == '+':
            result += number
        elif operator == '*':
            result *= number
        elif operator == '||':
            result = int(f"{result}{number}")
    return result


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    entries = entries.splitlines()

    sol = 0
    for line in entries:
        test_val, nums = line.split(":")
        nums = nums.split()
        for ops in itertools.product(['+', '*', '||'], repeat=len(nums) - 1):
            # this creates a string like '1 + 3 * 6' where all possible operators are tried
            # to pass into the eval function.
            expression = " ".join(num + " " + op for num, op in zip(nums, ops + ('',)))
            result = evaluate_left_to_right(expression)
            if int(result) == int(test_val):
                sol += int(test_val)
                break
    return sol
```
</details>

<hr>

### üéÖ Day 6

#### Day 6 Solution part 1

- **Answer**: 4890
- **Timing**: 0.001756906509399414

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 6 part 1
Solved by doing some magic
"""
import time
import sys
from itertools import cycle


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()

    entries = entries.strip().splitlines()
    visited = set()
    directions = cycle([(-1, 0), (0, 1), (1, 0), (0, -1)])
    guard_pos = None
    for i, row in enumerate(entries):
        if '^' in row:
            guard_pos = (i, row.index('^'))
            break
    current_dir = next(directions)
    while True:
        r, c = guard_pos
        visited.add((r, c))
        rl, cl = current_dir
        next_r, next_c = r + rl, c + cl
        if not (0 <= next_r < len(entries) and 0 <= next_c < len(entries[0])):
            break
        next_pos = entries[next_r][next_c]
        if next_pos == "#":
            current_dir = next(directions)
        else:
            guard_pos = (next_r, next_c)
    return len(visited)
```
</details>

#### Day 6 Solution part 2

- **Answer**: 1995
- **Timing**: 4.141064167022705

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 6 part 2
Solved by doing some magic
"""
import time
import sys
from itertools import cycle


def solution(input_file):

    with open(input_file, 'r') as file:
        entries = file.read()

    entries = entries.strip().splitlines()
    visited = set()
    directions = cycle([(-1, 0), (0, 1), (1, 0), (0, -1)])
    guard_pos = None
    initial_guard_pos = None

    for i, row in enumerate(entries):
        if '^' in row:
            guard_pos = (i, row.index('^'))
            initial_guard_pos = guard_pos
            break

    current_dir = next(directions)
    while True:
        r, c = guard_pos
        visited.add((r, c))
        rl, cl = current_dir
        next_r, next_c = r + rl, c + cl

        if not (0 <= next_r < len(entries) and 0 <= next_c < len(entries[0])):
            break

        next_pos = entries[next_r][next_c]
        if next_pos == "#":
            current_dir = next(directions)
        else:
            guard_pos = (next_r, next_c)

    def is_guard_fked(grid, init_pos):
        dirs = cycle([(-1, 0), (0, 1), (1, 0), (0, -1)])
        gp = init_pos
        cd = next(dirs)

        unique_paths = set()
        rows, cols = len(grid), len(grid[0])

        while True:
            r, c = gp
            rl, cl = cd
            next_r, next_c = r + rl, c + cl

            if not (0 <= next_r < rows and 0 <= next_c < cols):
                return False

            next_pos = grid[next_r][next_c]

            if (r, c, cd) in unique_paths:
                return True

            if next_pos == "#":
                cd = next(dirs)
            else:
                unique_paths.add((r, c, cd))
                gp = (next_r, next_c)

    sol = 0
    for loc in visited:
        if loc == initial_guard_pos:
            continue
        g = entries.copy()
        r, c = loc
        row_as_list = list(g[r])
        row_as_list[c] = "#"
        g[r] = ''.join(row_as_list)
        is_fked = is_guard_fked(g, initial_guard_pos)
        sol += is_fked
    return sol
```
</details>

<hr>

### ü§∂ Day 5

#### Day 5 Solution part 1

- **Answer**: 5248
- **Timing**: 0.0657038688659668

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 5 part 1
Solved by doing some magic
"""
import time
import sys


def swappy_papi(update, rules):
    changed = True
    while changed:
        changed = False
        for rule in rules:
            r1, r2 = rule
            if r1 in update and r2 in update:
                i1, i2 = update.index(r1), update.index(r2)
                if i1 > i2:
                    update[i1], update[i2] = update[i2], update[i1]
                    changed = True


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read().strip()

    rules, updates = [], []
    for entry in entries.splitlines():
        if "|" in entry:
            rules.append([int(e) for e in entry.split('|')])
        elif entry:
            updates.append([int(e) for e in entry.split(',')])

    sol = 0
    for update in updates:
        original = update.copy()
        swappy_papi(update, rules)
        if update == original:
            mid_index = (len(update) - 1) // 2
            sol += update[mid_index]

    return sol
```
</details>

#### Day 5 Solution part 2

- **Answer**: 4507
- **Timing**: 0.0657358169555664

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 5 part 2
Solved by doing some magic
"""
import time
import sys


def swappy_papi(update, rules):
    changed = True
    while changed:
        changed = False
        for rule in rules:
            r1, r2 = rule
            if r1 in update and r2 in update:
                i1, i2 = update.index(r1), update.index(r2)
                if i1 > i2:
                    update[i1], update[i2] = update[i2], update[i1]
                    changed = True


def solution(input_file):

    with open(input_file, 'r') as file:
        entries = file.read().strip()

    rules, updates = [], []
    for entry in entries.splitlines():
        if "|" in entry:
            rules.append([int(e) for e in entry.split('|')])
        elif entry:
            updates.append([int(e) for e in entry.split(',')])

    sol = 0
    for update in updates:
        original = update.copy()
        swappy_papi(update, rules)
        if update != original:
            mid_index = (len(update) - 1) // 2
            sol += update[mid_index]

    return sol
```
</details>

<hr>

### üéÑ Day 4

#### Day 4 Solution part 1

- **Answer**: 2618
- **Timing**: 0.024402141571044922

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 4 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()

	entries = entries.strip().splitlines()
	xmas = "XMAS"
	word_len = len(xmas)
	sol = 0
	directions = [
		(0, 1),  # Right
		(0, -1),  # Left
		(1, 0),  # Down
		(-1, 0),  # Up
		(1, 1),  # Down-right diagonal
		(-1, -1),  # Up-left diagonal
		(1, -1),  # Down-left diagonal
		(-1, 1),  # Up-right diagonal
	]
	for row in range(len(entries)):
		for col in range(len(entries[row])):
			if entries[row][col] == xmas[0]:
				for dr, dc in directions:
					current_word = ""
					for i in range(word_len):
						nr, nc = row + i * dr, col + i * dc
						if 0 <= nr < len(entries) and 0 <= nc < len(entries[nr]):
							current_word += entries[nr][nc]
						else:
							break
					if current_word == xmas:
						sol += 1
	return sol
```
</details>

#### Day 4 Solution part 2

- **Answer**: 2011
- **Timing**: 0.004395008087158203

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 4 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
    with open(input_file, "r") as file:
        entries = file.read().strip().splitlines()

    rows, cols = len(entries), len(entries[0])
    sol = 0

    for r in range(rows - 2):
        for c in range(cols - 2):
            top_left = entries[r][c]
            center = entries[r + 1][c + 1]
            bottom_right = entries[r + 2][c + 2]
            bottom_left = entries[r + 2][c]
            top_right = entries[r][c + 2]

            if (
                (
                    top_left == "M"
                    and center == "A"
                    and bottom_right == "S"
                    and bottom_left == "M"
                    and top_right == "S"
                )
                or (
                    top_left == "M"
                    and center == "A"
                    and bottom_right == "S"
                    and bottom_left == "S"
                    and top_right == "M"
                )
                or (
                    top_left == "S"
                    and center == "A"
                    and bottom_right == "M"
                    and bottom_left == "M"
                    and top_right == "S"
                )
                or (
                    top_left == "S"
                    and center == "A"
                    and bottom_right == "M"
                    and bottom_left == "S"
                    and top_right == "M"
                )
            ):
                sol += 1

    return sol
```
</details>

<hr>

### ü¶å Day 3

#### Day 3 Solution part 1

- **Answer**: 182619815
- **Timing**: 0.0004820823669433594

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 3 part 1
Solved by doing some magic
"""
import time
import sys
import re
from operator import mul


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	return sum(
		mul(*map(int, match.groups()))
		for match in re.finditer(r"mul\((\d+),(\d+)\)", entries.strip())
	)
```
</details>

#### Day 3 Solution part 2

- **Answer**: 80747545
- **Timing**: 0.007580995559692383

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 3 part 2
Solved by doing some magic
"""
import time
import sys
import re
from operator import mul


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read()
	do = True
	entries = entries.strip()
	offset = 0
	runnable_mem = ""
	for i in range(len(entries)):
		curr_mem = entries[offset:i]
		if "do()" in curr_mem:
			do = True
		if curr_mem.endswith("don't()"):
			do = False
			offset = i
		if do:
			runnable_mem += entries[i]
	return sum(
		mul(*map(int, match.groups()))
		for match in re.finditer(r"mul\((\d+),(\d+)\)", runnable_mem.strip())
	)
```
</details>

<hr>

### üéÅ Day 2

#### Day 2 Solution part 1

- **Answer**: 631
- **Timing**: 0.0014388561248779297

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 2 part 1
Solved by doing some magic
"""
import time
import sys


def safe(line):
    return (
            sorted(line) in [line, line[::-1]] and
            all(1 <= abs(a - b) <= 3 for a, b in zip(line, line[1:]))
    )


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    sol = 0
    entries = entries.splitlines()
    for line in entries:
        line = [int(c) for c in line.split()]
        sol += safe(line)
    return sol
```
</details>

#### Day 2 Solution part 2

- **Answer**: 665
- **Timing**: 0.0055348873138427734

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 2 part 1
Solved by doing some magic
"""
import time
import sys


def safe(line):
	return (
			sorted(line) in [line, line[::-1]] and
			all(1 <= abs(a - b) <= 3 for a, b in zip(line, line[1:]))
	)


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read()
	entries = entries.strip()
	# Parsing
	sol = 0
	entries = entries.splitlines()
	for line in entries:
		line = [int(c) for c in line.split()]
		can_add = False
		for j in range(len(line)):
			l2 = line[:j] + line[j + 1:]
			if safe(l2):
				can_add = True
		if can_add:
			sol += 1
	return sol
```
</details>

<hr>

### ‚õÑ Day 1

#### Day 1 Solution part 1

- **Answer**: 1646452
- **Timing**: 0.0004680156707763672

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 1 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()
	entries = entries.splitlines()
	left_side = []
	right_side = []
	for entry in entries:
		left, right = entry.split()
		left_side.append(int(left))
		right_side.append(int(right))
	left_side.sort()
	right_side.sort()
	return sum(r - l if r > l else l - r for (r, l) in zip(right_side, left_side))
```
</details>

#### Day 1 Solution part 2

- **Answer**: 23609874
- **Timing**: 0.0004222393035888672

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2024 day 1 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read()
	entries = entries.strip()
	entries = entries.splitlines()
	counter = {}
	sol = 0
	for entry in entries:
		left, right = entry.split()
		if right not in counter:
			counter[right] = 1
		else:
			counter[right] += 1
	for entry in entries:
		left, right = entry.split()
		sol += counter.get(left, 0) * int(left)

	return sol
```
</details>

<hr>

### Year 2023

### üîî Day 11

#### Day 11 Solution part 1

- **Answer**: 9543156
- **Timing**: 0.2068040370941162

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 11 part 1
Solved by doing some magic
"""
import time
import sys
import pandas as pd


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()

    # Parsing
    df = pd.DataFrame([list(char) for char in entries.strip().splitlines()])
    # get locations of columns that are 'blank'
    dot_columns = df.columns[df.eq('.').all()]
    # get locations of rows that are 'blank'
    dot_rows = df.index[df.eq('.').all(axis=1)]

    # turn locations into tuples.
    positions = [(i, j) for i, row in enumerate(df.values.tolist()) for j, val in enumerate(row) if val == '#']

    sol = 0
    # iter over positions
    for i, pos1 in enumerate(positions, 1):
        for pos2 in positions[i:]:
            # get diff in rows/cols
            d = abs(pos2[0] - pos1[0]) + abs(pos2[1] - pos1[1])
            # adjust for duplicated galaxy locations along cols and rows
            for col in dot_columns:
                if pos1[1] <= col <= pos2[1] or pos2[1] <= col <= pos1[1]:
                    d += 1
            for row in dot_rows:
                if pos1[0] <= row <= pos2[0] or pos2[0] <= row <= pos1[0]:
                    d += 1
            sol += d
    return sol
```
</details>

#### Day 11 Solution part 2

- **Answer**: 625243292686
- **Timing**: 0.20897912979125977

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 11 part 2
Solved by doing some magic
"""
import time
import sys

import pandas as pd


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read()

    # Parsing
    df = pd.DataFrame([list(char) for char in entries.strip().splitlines()])
    # get locations of columns that are 'blank'
    dot_columns = df.columns[df.eq('.').all()]
    # get locations of rows that are 'blank'
    dot_rows = df.index[df.eq('.').all(axis=1)]

    # turn locations into tuples.
    positions = [(i, j) for i, row in enumerate(df.values.tolist()) for j, val in enumerate(row) if val == '#']

    sol = 0
    # iter over positions
    for i, pos1 in enumerate(positions, 1):
        for pos2 in positions[i:]:
            # get diff in rows/cols
            d = abs(pos2[0] - pos1[0]) + abs(pos2[1] - pos1[1])
            # adjust for duplicated galaxy locations along cols and rows
            for col in dot_columns:
                if pos1[1] <= col <= pos2[1] or pos2[1] <= col <= pos1[1]:
                    d += 1000000 - 1
            for row in dot_rows:
                if pos1[0] <= row <= pos2[0] or pos2[0] <= row <= pos1[0]:
                    d += 1000000 - 1
            sol += d
    return sol
```
</details>

<hr>

### üç™ Day 9

#### Day 9 Solution part 1

- **Answer**: 1974232246
- **Timing**: 0.005129098892211914

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 9 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	rows = [[int(val) for val in e.split()] for e in entries.splitlines()]
	sol = 0
	for row in rows:
		history = [row]
		while set(history[-1]) != {0}:
			# while last row is not all 0 simply grab the latest row history and subtract the next value
			history.append(
				[history[-1][ix + 1] - v for ix, v in enumerate(history[-1]) if ix + 1 < len(history[-1])]
			)
		while len(history) > 1:
			l = history.pop(-1)
			d = l[-1]
			history[-1].append(history[-1][-1] + d)
		sol += history[0][-1]

	return sol
```
</details>

#### Day 9 Solution part 2

- **Answer**: 928
- **Timing**: 0.005249738693237305

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 9 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	rows = [[int(val) for val in e.split()] for e in entries.splitlines()]
	sol = 0
	for row in rows:
		row = row[::-1]
		history = [row]
		while set(history[-1]) != {0}:
			# while last row is not all 0 simply grab the latest row history and subtract the next value
			history.append(
				[history[-1][ix + 1] - v for ix, v in enumerate(history[-1]) if ix + 1 < len(history[-1])]
			)
		while len(history) > 1:
			l = history.pop(-1)
			d = l[-1]
			history[-1].append(history[-1][-1] + d)
		sol += history[0][-1]

	return sol
```
</details>

<hr>

### üåü Day 8

#### Day 8 Solution part 1

- **Answer**: 20093
- **Timing**: 0.0017158985137939453

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 8 part 1
Solved by doing some magic
"""
import itertools
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()

	# Parsing
	rl_set, nodes = entries.split("\n\n")

	mapping = {}
	nodes = nodes.splitlines()
	for node in nodes:
		ele, maps_set = node.split("=")
		ele = ele.strip()
		# build a map of the graph with Left/Right options.
		# Ex: QRX = (XNN,TCJ) -> {'QRX': {'L': 'XNN', 'R': 'TCJ'}}
		maps_set = maps_set.strip().strip("(").strip(")").split(",")
		ele_mapping = {char: maps_set[ix].strip() for ix, char in enumerate(["L","R"])}
		mapping[ele] = ele_mapping

	# @Tristan next time read the question properly.
	current_key = "AAA"
	target_key = "ZZZ"
	# cycle through instructions and map until solution is found.
	for sol, p in enumerate(itertools.cycle(rl_set)):
		if current_key == target_key:
			return sol
		current_key = mapping[current_key][p]
```
</details>

#### Day 8 Solution part 2

- **Answer**: 22103062509257
- **Timing**: 0.011484861373901367

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 8 part 2
Solved by doing some magic
"""
import itertools
import time
import sys
from math import gcd

def iter_graph(graph,rl_set, start_node, ends):
    # cycle through instructions and map until solution is found.
    for sol, p in enumerate(itertools.cycle(rl_set)):
        if start_node in ends:
            return sol
        start_node = graph[start_node][p]

def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()
    entries = entries.strip()

    # Parsing
    rl_set, nodes = entries.split("\n\n")

    mapping = {}
    nodes = nodes.splitlines()
    for node in nodes:
        ele, maps_set = node.split("=")
        ele = ele.strip()
        # build a map of the graph with Left/Right options.
        # Ex: QRX = (XNN,TCJ) -> {'QRX': {'L': 'XNN', 'R': 'TCJ'}}
        maps_set = maps_set.strip().strip("(").strip(")").split(",")
        ele_mapping = {char: maps_set[ix].strip() for ix, char in enumerate(["L","R"])}
        mapping[ele] = ele_mapping

    starting_nodes = [node for node in mapping if node[-1] == 'A']
    ending_nodes = [node for node in mapping if node[-1] == 'Z']
    sol = 1
    for i in [iter_graph(mapping, rl_set, s, ending_nodes) for s in starting_nodes]:
        sol = sol * i // gcd(sol, i)
    return sol
```
</details>

<hr>

### ‚ùÑÔ∏è Day 7

#### Day 7 Solution part 1

- **Answer**: 251106089
- **Timing**: 0.002722024917602539

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 7 part 1
Solved by doing some magic
"""
import time
import sys
from collections import Counter


def get_numerical_card(card):
    if card.isdigit():
        return int(card)
    return {'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}[card]


def get_hand_strength(hand):
    trick_strength = tuple(sorted(Counter(hand).values(), reverse=True))
    return trick_strength, hand

def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()
    entries = entries.strip()
    hands = []
    for line in entries.splitlines():
        hand, bid = line.split()
        hands.append((tuple(get_numerical_card(c) for c in hand), int(bid)))
    hands.sort(key=lambda p: get_hand_strength(p[0]))
    return sum(int(pair[1]) * (i + 1) for i, pair in enumerate(hands))
```
</details>

#### Day 7 Solution part 2

- **Answer**: 249620106
- **Timing**: 0.003551006317138672

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 7 part 2
Solved by doing some magic
"""
import time
import sys
from collections import Counter

def get_numerical_card(card):
    if card.isdigit():
        return int(card)
    return {'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}[card]


def get_hand_strength(hand):
    num_jokers = hand.count(11)
    hand_without_jokers = tuple(card for card in hand if card != 11)
    trick_strength = list(sorted(Counter(hand_without_jokers).values(), reverse=True))
    if not trick_strength:
        trick_strength = (5,)
    else:
        trick_strength[0] += num_jokers
    trick_strength = tuple(trick_strength)

    new_hand = tuple(1 if card == 11 else card for card in hand)
    return trick_strength, new_hand


def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()
    entries = entries.strip()
    hands = []
    for line in entries.splitlines():
        hand, bid = line.split()
        hands.append((tuple(get_numerical_card(c) for c in hand), int(bid)))
    hands.sort(key=lambda p: get_hand_strength(p[0]))
    return sum(int(pair[1]) * (i + 1) for i, pair in enumerate(hands))
```
</details>

<hr>

### üéÖ Day 6

#### Day 6 Solution part 1

- **Answer**: 3316275
- **Timing**: 5.412101745605469e-05

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 6 part 1
Solved by doing some magic
"""
import time
import sys
from functools import reduce


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	# Parsing
	entries = entries.strip().splitlines()
	simulations = []

	time_entries = [int(e) for e in entries[0].split(":")[-1].strip().split()]
	distance_entries = [int(e) for e in entries[1].split(":")[-1].strip().split()]
	for i, (time_entry, record_distance) in enumerate(zip(time_entries, distance_entries)):
		for time_held in range(time_entry):
			if (time_held * (time_entry - time_held)) > record_distance:
				if len(simulations) < len(time_entries):
					simulations.append(0)
				simulations[i] += 1
	return reduce(lambda x, y: x * y, simulations, 1)
```
</details>

#### Day 6 Solution part 2

- **Answer**: 27102791
- **Timing**: 2.270949125289917

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 6 part 2
Solved by doing some magic
"""
import time
import sys
from functools import reduce


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	# Parsing
	entries = entries.strip().splitlines()
	time_entry = int("".join(entries[0].split(":")[-1].strip().split()))
	record_distance = int("".join(entries[1].split(":")[-1].strip().split()))
	return sum(
		time_held * (time_entry - time_held) > record_distance
		for time_held in range(time_entry)
	)
```
</details>

<hr>

### ü§∂ Day 5

#### Day 5 Solution part 1

- **Answer**: 199602917
- **Timing**: 0.00039315223693847656

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 5 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()

	# Parsing
	entries = entries.strip()
	parts = entries.split("\n\n")
	seeds = [int(seed) for seed in parts[0].split(":")[-1].strip().split()]
	mapping = {}

	for m in parts[1:]:
		lines = m.splitlines()
		name = lines[0].strip(":")
		soil_ranges = []
		seed_ranges = []

		for line in lines[1:]:
			destination_range_start, source_range_start, length = map(int, line.split())
			soil_ranges.append((destination_range_start, destination_range_start + length - 1))
			seed_ranges.append((source_range_start, source_range_start + length - 1))
		mapping[name] = {'soil_ranges': soil_ranges, 'seed_ranges': seed_ranges}

	locations = []
	for seed in seeds:
		seed_map = {}
		current_seed_number = seed
		for i, name in enumerate(mapping):
			seed_ranges = mapping[name].get("seed_ranges")
			soil_ranges = mapping[name].get("soil_ranges")
			for seed_range, target_range in zip(seed_ranges, soil_ranges):
				# min, max of range is stored as tuple.
				if seed_range[0] <= current_seed_number <= seed_range[1]:
					current_seed_number += target_range[0] - seed_range[0]
					break
			seed_map[name] = current_seed_number
		locations.append(seed_map["humidity-to-location map"])
	return min(locations)
```
</details>

#### Day 5 Solution part 2

- **Answer**: 2254686
- **Timing**: 13.04607605934143

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 5 part 2
Solved by doing some magic
"""
import time
import sys


def parse_map(conversion_map_raw):
    map_lst = conversion_map_raw.splitlines()
    conversion_rules = []
    for row in map_lst[1:]:
        dest, source, range_length = [int(num) for num in row.split()]
        conversion_rules.append((dest, source, range_length))
    return conversion_rules

def find_location(seed, maps):
    current = seed
    for rule in maps:
        for dest, source, range_length in rule:
            if source <= current < source + range_length:
                current = current - source + dest
                break
    return current

def solution(input_file):
    with open(input_file,'r') as file:
        seeds_raw, *conversion_maps_raw = file.read().split("\n\n")
    seeds = [int(num) for num in seeds_raw.split()[1:]]
    maps = list(map(parse_map, conversion_maps_raw))

    seeds_ranges = [
        (seeds[i - 1], seeds[i - 1] + seed)
        for i, seed in enumerate(seeds)
        if i % 2 == 1
    ]
    maps = [[(end, s, seed_range) for s, end, seed_range in rule] for rule in maps][::-1]
    location = 0
    while True:
        seed = find_location(location, maps)
        if any(s <= seed < end for s, end in seeds_ranges):
            return location
        location += 1
```
</details>

<hr>

### üéÑ Day 4

#### Day 4 Solution part 1

- **Answer**: 23847
- **Timing**: 0.0007059574127197266

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 4 part 1
Solved by doing some magic
"""
import time
import sys
from functools import reduce


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()
	sol = 0
	for card in entries.splitlines():
		winning_set, your_set = card.split(":")[-1].strip().split("|")
		# Check if shared values between lists
		if inner := set(winning_set.split()).intersection(set(your_set.split())):
			sol += reduce(lambda x, y: x * 2, list(inner)[:-1], 1)
	return sol
```
</details>

#### Day 4 Solution part 2

- **Answer**: 8570000
- **Timing**: 1.3327951431274414

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 4 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()
	# will store the card number + copies of the card
	mapping = {k+1:1 for k in range(len(entries.splitlines()))}
	for i, card in enumerate(entries.splitlines(), 1):
		# can set the initial instance of the card.
		num_matches = 0
		winning_set, your_set = card.split(":")[-1].strip().split("|")
		# Check if shared values between lists
		if inner := set(winning_set.split()).intersection(set(your_set.split())):
			num_matches = len(inner)
			# for each match add the new instance to mapping
			for ix in range(num_matches):
				mapping[ix + i + 1] = mapping.get(ix + i + 1, 0) + 1
		# for copies of card, clone forwards
		for _ in range(mapping.get(i) - 1):
			for ix in range(num_matches):
				mapping[ix + i + 1] = mapping.get(ix + i + 1, 0) + 1
	return sum(mapping.values())
```
</details>

<hr>

### ü¶å Day 3

#### Day 3 Solution part 1

- **Answer**: 535078
- **Timing**: 0.005175113677978516

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 3 part 1
Solved by doing some magic
"""

import itertools
import time
import sys


def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()

    result = 0
    entries = entries.strip()

    # Parsing
    entries = entries.splitlines()

    for i, line in enumerate(entries):
        current_number = ""
        add_number = False

        for idx, char in enumerate(line):
            if char.isdigit():
                current_number += char
                # for each character in the 3x3 grid around the digit
                for x, y in itertools.product(
                        range(max(0, i - 1), min(len(entries), i + 2)),
                        range(max(0, idx - 1), min(len(line), idx + 2))
                ):
                    # exclude the digit itself
                    if x == i and y == idx:
                        continue
                    # if the character is not a digit and not a dot its a symbol
                    if entries[x][y] != "." and not entries[x][y].isdigit():
                        add_number = True
            elif add_number and current_number != "":
                result += int(current_number)
                add_number = False
                current_number = ""
            else:
                add_number = False
                current_number = ""
        if add_number and current_number != "":
            result += int(current_number)
    return result
```
</details>

#### Day 3 Solution part 2

- **Answer**: 75312571
- **Timing**: 0.006545066833496094

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 3 part 2
Solved by doing some magic
"""

import itertools
import time
import sys
from collections import defaultdict


def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()

    entries = entries.strip()

    # Parsing
    entries = entries.splitlines()
    gears = defaultdict(list)
    for i, line in enumerate(entries):
        current_number = ""
        # symbols are tuple of (symbol, x, y)
        adjacent_symbols = set()

        for idx, char in enumerate(line):
            if char.isdigit():
                current_number += char
                # same eval as p1
                for x, y in itertools.product(
		                range(max(0, i - 1), min(len(entries), i + 2)),
		                range(max(0, idx - 1), min(len(line), idx + 2))
                ):
                    if x == i and y == idx:
                        continue
                    if entries[x][y] != "." and not entries[x][y].isdigit():
                        # track position
                        adjacent_symbols.add((entries[x][y], x, y))

            elif len(adjacent_symbols) != 0 and current_number != "":
                for symbol, x, y in adjacent_symbols:
                    if symbol == "*":
                        gears[(x, y)].append(int(current_number))
                adjacent_symbols = set()
                current_number = ""
            else:
                adjacent_symbols = set()
                current_number = ""
        if len(adjacent_symbols) != 0 and current_number != "":
            for symbol, x, y in adjacent_symbols:
                if symbol == "*":
                    gears[(x, y)].append(int(current_number))
    # Sum only if 2 exact parts
    return sum(
        values[0] * values[1] for values in gears.values() if len(values) == 2
    )
```
</details>

<hr>

### üéÅ Day 2

#### Day 2 Solution part 1

- **Answer**: 2061
- **Timing**: 0.00038504600524902344

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 2 part 1
Solved by doing some magic
"""
import time
import sys

def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read().strip().splitlines()

    # Setup limits
    config = {"green": 13, "blue": 14, "red": 12}
    invalid_games = set()
    result = 0
    for line in entries:
        game, game_sets = line.split(":")
        game_id = int(game.split()[-1])
        for gs in game_sets.strip().split(";"):
            # Check if any cube is over config limit and track that gameID as invalid
            if any(config[color] < int(num) for num, color in (r.split() for r in gs.split(","))):
                invalid_games.add(game_id)
                break
        # Remaining games are valid
        if game_id not in invalid_games:
            result += game_id

    return result
```
</details>

#### Day 2 Solution part 2

- **Answer**: 72596
- **Timing**: 0.0005440711975097656

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 2 part 2
Solved by doing some magic
"""
import time
import sys
from functools import reduce
import math


def solution(input_file):
	with open(input_file, 'r') as file:
		entries = file.read().strip().splitlines()

	result = 0
	for line in entries:
		game, game_sets = line.split(":")
		config = {}
		for gs in game_sets.strip().split(";"):
			for num, color in (r.split() for r in gs.split(",")):
				config[color] = max(config.get(color,0), int(num))
		power = reduce(lambda x, y: x * y, config.values(), 1)
		result += power
	return result
```
</details>

<hr>

### ‚õÑ Day 1

#### Day 1 Solution part 1

- **Answer**: 54644
- **Timing**: 0.0008640289306640625

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 1 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	entries = entries.strip()
	result = 0
	entries = entries.splitlines()
	for line in entries:
		numbers_in_line = [char for char in line if not char.isalpha()]
		result += int(f"{numbers_in_line[0]}{numbers_in_line[-1]}")
	return result
```
</details>

#### Day 1 Solution part 2

- **Answer**: 53348
- **Timing**: 0.007102012634277344

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2023 day 1 part 2
Solved by doing some magic
"""
import time
import re
import sys

word_digit_pairs = [
    ('one', '1'),
    ('two', '2'),
    ('three', '3'),
    ('four', '4'),
    ('five', '5'),
    ('six', '6'),
    ('seven', '7'),
    ('eight', '8'),
    ('nine', '9')
]

def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read()
    entries = entries.strip()
    result = 0
    entries = entries.splitlines()
    for line in entries:
        # has to be a better way than this???
        numbers_found = []
        for word, digit in word_digit_pairs:
            matches = re.finditer(word, line)
            numbers_found.extend((digit, match.start()) for match in matches)
        [numbers_found.append((char, pos)) for pos, char in enumerate(line) if not char.isalpha()]
        numbers_in_line = sorted(numbers_found,key=lambda x: x[1])
        result += int(f"{numbers_in_line[0][0]}{numbers_in_line[-1][0]}")
    return result
```
</details>

<hr>

### Year 2022

### üîî Day 11

#### Day 11 Solution part 1

- **Answer**: 119715
- **Timing**: 0.004992008209228516

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 11 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = [line.strip() for line in file.readlines()]

	monkeys = {}
	num_rounds = 20
	monk_count = 0
	for line in entries:
		if not line.strip():
			monk_count += 1
			continue
		if line.startswith("Monkey"):
			monkeys[f"monkey__{monk_count}"] = {
				"starting_items": [],
				"operation": "",
				"test": None, "true": "",
				"false": "",
				"monkeys_inspected": 0
			}
		if line.startswith("Starting"):
			monkeys[f"monkey__{monk_count}"]['starting_items'] = [int(num) for num in line.split(":")[-1].strip().split(",")]
		if line.startswith("Operation"):
			monkeys[f"monkey__{monk_count}"]['operation'] = line.split(":")[-1].split()
		if line.startswith("Test"):
			monkeys[f"monkey__{monk_count}"]['test'] = line.split(":")[-1].strip().split()[-1]
		if line.startswith("If true"):
			monkeys[f"monkey__{monk_count}"]['true'] = line.split(":")[-1].strip()
		if line.startswith("If false"):
			monkeys[f"monkey__{monk_count}"]['false'] = line.split(":")[-1].strip()

	for _ in range(num_rounds):
		for monkey, values in monkeys.items():
			for _ in range(len(values["starting_items"])):
				item = values["starting_items"].pop(0)
				monkeys[monkey]["monkeys_inspected"] += 1
				multiplier = int(values["operation"][-1]) if values["operation"][-1] != "old" else item
				worry = eval(f"{item} {values['operation'][-2]} {multiplier}") // 3
				passes_test = values["true"] if worry % int(values["test"]) == 0 else values["false"]
				monkeys[f"monkey__{int(passes_test.split()[-1])}"]['starting_items'].append(worry)
	monkey1, monkey2 = sorted([monkey["monkeys_inspected"] for monkey in monkeys.values()], reverse=True)[:2]
	return monkey1 * monkey2
```
</details>

#### Day 11 Solution part 2

- **Answer**: 18085004878
- **Timing**: 2.199301242828369

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 11 part 2
Solved by doing some magic
"""
import time
import sys
import numpy as np


def solution(input_file):
	with open(input_file,'r') as file:
		entries = [line.strip() for line in file.readlines()]

	monkeys = {}
	num_rounds = 10000
	monk_count = 0
	for line in entries:
		if not line.strip():
			monk_count += 1
			continue
		if line.startswith("Monkey"):
			monkeys[f"monkey__{monk_count}"] = {
				"starting_items": [],
				"operation": "",
				"test": None, "true": "",
				"false": "",
				"monkeys_inspected": 0
			}
		if line.startswith("Starting"):
			monkeys[f"monkey__{monk_count}"]['starting_items'] = [int(num) for num in line.split(":")[-1].strip().split(",")]
		if line.startswith("Operation"):
			monkeys[f"monkey__{monk_count}"]['operation'] = line.split(":")[-1].split()
		if line.startswith("Test"):
			monkeys[f"monkey__{monk_count}"]['test'] = line.split(":")[-1].strip().split()[-1]
		if line.startswith("If true"):
			monkeys[f"monkey__{monk_count}"]['true'] = line.split(":")[-1].strip()
		if line.startswith("If false"):
			monkeys[f"monkey__{monk_count}"]['false'] = line.split(":")[-1].strip()

	worry_divisor = np.prod(
		[int(test['test']) for test in monkeys.values()]
	)

	for _ in range(num_rounds):
		for monkey, values in monkeys.items():
			for _ in range(len(values["starting_items"])):
				item = values["starting_items"].pop(0)
				monkeys[monkey]["monkeys_inspected"] += 1
				multiplier = int(values["operation"][-1]) if values["operation"][-1] != "old" else item
				worry = eval(f"{item} {values['operation'][-2]} {multiplier}")
				worry = int(worry % worry_divisor)
				passes_test = values["true"] if worry % int(values["test"]) == 0 else values["false"]
				monkeys[f"monkey__{int(passes_test.split()[-1])}"]['starting_items'].append(worry)
	monkey1, monkey2 = sorted([monkey["monkeys_inspected"] for monkey in monkeys.values()], reverse=True)[:2]
	return monkey1 * monkey2
```
</details>

<hr>

### ‚õ∏Ô∏è Day 10

#### Day 10 Solution part 1

- **Answer**: 10760
- **Timing**: 0.00012111663818359375

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 10 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()

	sol = 0
	register_x = 1
	inst = []
	entries = entries.strip().splitlines()
	# add buffer tick if not 'noop'
	for entry in entries:
		splitln = entry.split()
		inst.extend((['noop', 0], [splitln[0], int(splitln[1])])) if len(splitln) > 1 else inst.append([splitln[0], 0])

	for cycle, (instruction, value) in enumerate(inst, 1):
		if (cycle + 20) % 40 == 0:
			sol += register_x * cycle
		register_x += value

	return sol
```
</details>

#### Day 10 Solution part 2

- **Answer**: FPGPHFGH
- **Timing**: 0.00017881393432617188

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 10 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()

	register_x = 1
	inst = []
	entries = entries.strip().splitlines()
	screen = [['.']*40 for _ in range(6)]
	# add buffer tick if not 'noop'
	for entry in entries:
		splitln = entry.split()
		inst.extend((['noop', 0], [splitln[0], int(splitln[1])])) if len(splitln) > 1 else inst.append([splitln[0], 0])

	for cycle, (instruction, value) in enumerate(inst, 1):
		rx, cx = divmod(cycle-1, 40)
		if register_x - 1 <= cx <= register_x + 1:
			screen[rx][cx] = '#'
		register_x += value

	print('The result for solution 2 is:')
	for row in screen:
		for ele in row:
			print(ele, end=' ')
		print()

	return 'FPGPHFGH'
```
</details>

<hr>

### üç™ Day 9

#### Day 9 Solution part 1

- **Answer**: 6023
- **Timing**: 0.009848833084106445

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 9 part 1
Solved by doing some magic
"""
import time
import sys


class Coordinates:
	def __init__(self, x=0, y=0):
		self.x = x
		self.y = y
		self.direction_mapping = {'D': (0, -1), 'U': (0, 1), 'R': (1, 0), 'L': (-1, 0)}

	def move_with_direction(self, direction):
		x_shift, y_shift = self.direction_mapping[direction]
		self.x += x_shift
		self.y += y_shift

	def move_to_become_neighbor(self, other_knot):
		if abs(self.x - other_knot.x) == 2 and abs(self.y - other_knot.y) == 2:
			self.x = self.x + int((other_knot.x - self.x) / 2)
			self.y = self.y + int((other_knot.y - self.y) / 2)
		elif abs(self.x - other_knot.x) == 2:
			self.x = self.x + int((other_knot.x - self.x) / 2)
			self.y = other_knot.y
		elif abs(self.y - other_knot.y) == 2:
			self.x = other_knot.x
			self.y = self.y + int((other_knot.y - self.y) / 2)

	@property
	def as_tuple(self):
		return self.x, self.y

	def __repr__(self):
		return f"[{self.x}, {self.y}]"


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().strip().splitlines()

	number_knots = 2
	knots = [Coordinates() for _ in range(number_knots)]
	tail_coordinates_set = set()
	for direction, number in [row.split() for row in entries]:
		for _ in range(int(number)):
			# this is our parent knot, rest are tail
			knots[0].move_with_direction(direction)
			# offset parent knot and move children to be all fuzzy wuzzy with the parent
			for index, knot in enumerate(knots[1:number_knots], 1):
				knot.move_to_become_neighbor(knots[index - 1])
			# add tail knot to unique set
			tail_coordinates_set.add(knots[number_knots - 1].as_tuple)
	return len(tail_coordinates_set)
```
</details>

#### Day 9 Solution part 2

- **Answer**: 2533
- **Timing**: 0.0349581241607666

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 9 part 2
Solved by doing some magic
"""
import time
import sys


class Coordinates:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.direction_mapping = {'D': (0, -1), 'U': (0, 1), 'R': (1, 0), 'L': (-1, 0)}

    def move_with_direction(self, direction):
        x_shift, y_shift = self.direction_mapping[direction]
        self.x += x_shift
        self.y += y_shift

    def move_to_become_neighbor(self, other_knot):
        if abs(self.x - other_knot.x) == 2 and abs(self.y - other_knot.y) == 2:
            self.x = self.x + int((other_knot.x - self.x) / 2)
            self.y = self.y + int((other_knot.y - self.y) / 2)
        elif abs(self.x - other_knot.x) == 2:
            self.x = self.x + int((other_knot.x - self.x) / 2)
            self.y = other_knot.y
        elif abs(self.y - other_knot.y) == 2:
            self.x = other_knot.x
            self.y = self.y + int((other_knot.y - self.y) / 2)

    @property
    def as_tuple(self):
        return self.x, self.y

    def __repr__(self):
        return f"[{self.x}, {self.y}]"


def solution(input_file):
    with open(input_file,'r') as file:
        entries = file.read().strip().splitlines()

    number_knots = 10
    knots = [Coordinates() for _ in range(number_knots)]
    tail_coordinates_set = set()
    for direction, number in [row.split() for row in entries]:
        for _ in range(int(number)):
            # this is our parent knot, rest are tail
            knots[0].move_with_direction(direction)
            # offset parent knot and move children to be all fuzzy wuzzy with the parent
            for index, knot in enumerate(knots[1:number_knots], 1):
                knot.move_to_become_neighbor(knots[index - 1])
            # add tail knot to unique set
            tail_coordinates_set.add(knots[number_knots - 1].as_tuple)
    return len(tail_coordinates_set)
```
</details>

<hr>

### üåü Day 8

#### Day 8 Solution part 1

- **Answer**: 1801
- **Timing**: 0.1211860179901123

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 8 part 1
Solved by doing some magic
"""
import time
import sys
import numpy as np


def is_visible(row_ix, column_ix, grid):
	if row_ix in [0, len(grid) - 1]:
		return True
	if column_ix in [0, len(grid[row_ix]) - 1]:
		return True

	value = grid[row_ix][column_ix]
	row = grid[row_ix]
	column = [grid[row_ix][column_ix] for row_ix in range(len(grid))]

	left = all(x < value for x in row[:column_ix])
	right = all(x < value for x in row[column_ix + 1:])
	top = all(x < value for x in column[:row_ix])
	bottom = all(x < value for x in column[row_ix + 1:])

	return left or right or top or bottom


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().splitlines()
	grid = np.array([list(row.strip()) for row in entries]).astype('int')
	vis = 0
	for row_num, row in enumerate(grid):
		for col_num, col in enumerate(row):
			if is_visible(row_num, col_num, grid):
				vis += 1
	return vis
```
</details>

#### Day 8 Solution part 2

- **Answer**: 209880
- **Timing**: 0.11428189277648926

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 8 part 2
Solved by doing some magic
"""
import time
import sys
import numpy as np


def get_score(row_ix, column_ix, grid):
    value = grid[row_ix][column_ix]
    row = grid[row_ix]
    column = [grid[row_ix][column_ix] for row_ix in range(len(grid))]

    left, right, top, bottom = 0, 0, 0, 0

    # Check left
    for x in reversed(row[:column_ix]):
        left += 1
        if x >= value:
            break

    # Check right
    for x in row[column_ix + 1:]:
        right += 1
        if x >= value:
            break

    # Check top
    for x in reversed(column[:row_ix]):
        top += 1
        if x >= value:
            break

    # Check bottom
    for x in column[row_ix + 1:]:
        bottom += 1
        if x >= value:
            break

    return left * right * top * bottom


def solution(input_file):
    with open(input_file, 'r') as file:
        entries = file.read().splitlines()
    grid = np.array([list(row.strip()) for row in entries]).astype('int')
    score = []
    for row_num, row in enumerate(grid):
        score.extend(get_score(row_num, col_num, grid) for col_num, col in enumerate(row))
    return max(score)
```
</details>

<hr>

### ‚ùÑÔ∏è Day 7

#### Day 7 Solution part 1

- **Answer**: 1306611
- **Timing**: 0.0012087821960449219

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 7 part 1
Solved by doing some magic
"""
import time
import sys
from string import digits


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().strip().splitlines()
	dir_sizes = {}
	checked_f = {}
	crnt_dir = []

	for line in entries:
		ln = line.strip()
		if ln.startswith('$ cd'):
			if not crnt_dir:
				crnt_dir.append('/')
			elif ln.split(' ')[2] == '/':
				crnt_dir = crnt_dir[0]
			elif ln.split(' ')[2] == '..':
				crnt_dir = crnt_dir[:-1]
			else:
				crnt_dir.append(ln.split(' ')[2])

		elif ln[0] in digits:
			dir_str = '\\'.join(crnt_dir)
			if dir_str not in checked_f.keys():
				checked_f[dir_str] = []
			if ln.split(' ')[1] not in checked_f[dir_str]:
				checked_f[dir_str].append(ln.split(' ')[1])
				for f in range(len(crnt_dir)+1):
					if '\\'.join(crnt_dir[:f]) not in dir_sizes.keys():
						if '\\'.join(crnt_dir[:f]).strip() == '':
							continue
						dir_sizes['\\'.join(crnt_dir[:f])] = 0
					dir_sizes['\\'.join(crnt_dir[:f])] += int(line.split(' ')[0])
	return sum(n for n in dir_sizes.values() if n < 100000)
```
</details>

#### Day 7 Solution part 2

- **Answer**: 13210366
- **Timing**: 0.0012161731719970703

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 7 part 2
Solved by doing some magic
"""
import time
import sys
from string import digits


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().strip().splitlines()
	dir_sizes = {}
	checked_f = {}
	crnt_dir = []

	for line in entries:
		ln = line.strip()
		if ln.startswith('$ cd'):
			if not crnt_dir:
				crnt_dir.append('/')
			elif ln.split(' ')[2] == '/':
				crnt_dir = crnt_dir[0]
			elif ln.split(' ')[2] == '..':
				crnt_dir = crnt_dir[:-1]
			else:
				crnt_dir.append(ln.split(' ')[2])

		elif ln[0] in digits:
			dir_str = '\\'.join(crnt_dir)
			if dir_str not in checked_f.keys():
				checked_f[dir_str] = []
			if ln.split(' ')[1] not in checked_f[dir_str]:
				checked_f[dir_str].append(ln.split(' ')[1])
				for f in range(len(crnt_dir)+1):
					if '\\'.join(crnt_dir[:f]) not in dir_sizes.keys():
						if '\\'.join(crnt_dir[:f]).strip() == '':
							continue
						dir_sizes['\\'.join(crnt_dir[:f])] = 0
					dir_sizes['\\'.join(crnt_dir[:f])] += int(line.split(' ')[0])
	sort_vals = sorted(dir_sizes.values())
	space_needed = 30000000-(70000000-sort_vals[-1])
	for n in sort_vals:
		if n >= space_needed:
			return n
```
</details>

<hr>

### üéÖ Day 6

#### Day 6 Solution part 1

- **Answer**: 1142
- **Timing**: 0.00025177001953125

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 6 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().strip()
	min_char_before_marker = 4

	for i, char in enumerate(entries, 1):
		if i < min_char_before_marker:
			continue
		if len(set(entries[i - min_char_before_marker: i])) == min_char_before_marker:
			return i
```
</details>

#### Day 6 Solution part 2

- **Answer**: 2803
- **Timing**: 0.0011069774627685547

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 6 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read().strip()
	min_char_before_marker = 14

	for i, char in enumerate(entries, 1):
		if i < min_char_before_marker:
			continue
		if len(set(entries[i - min_char_before_marker: i])) == min_char_before_marker:
			return i
```
</details>

<hr>

### ü§∂ Day 5

#### Day 5 Solution part 1

- **Answer**: TBVFVDZPN
- **Timing**: 0.003515958786010742

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 5 part 1
Solved by doing some magic
"""
import time
import sys
import pandas as pd


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.readlines()
	instructions = [line.strip() for line in entries if 'move' in line]
	above_instructions = [line for line in entries if 'move' not in line]
	number_cols = max(int(num) for num in above_instructions[-2].split())  # get how many cols there are supposed to be
	crates = above_instructions[:-2]  # last items is a newline and numbers row so we remove
	data = []
	for line in crates:
		line = line.replace("    ", "\n").replace("\n", " ").split(" ")  # elf style parsing. dont ask.
		items = line[:-1] if not line[-1] else line  # strips out lines that end in blanks
		data.append(items)
	df = pd.DataFrame(columns=[str(num + 1) for num in range(number_cols)], data=data)
	final_arr = [[val for val in a if val] for a in [df[col].tolist() for col in df.columns]]

	for instruction in instructions:
		action, number_to_move, from_col, from_col_num, to_col, to_col_num = instruction.split()  # <-- lol
		from_col_num = int(from_col_num)
		number_to_move = int(number_to_move)
		to_col_num = int(to_col_num)
		for _ in range(number_to_move):
			# get the value to move
			arr_value_move = final_arr[from_col_num - 1][0]
			# update the array with removed value
			final_arr[from_col_num - 1] = final_arr[from_col_num - 1][1:]
			# update the new array
			final_arr[to_col_num - 1] = [arr_value_move] + final_arr[to_col_num - 1]
	return "".join(arr[0] for arr in final_arr).replace("[","").replace("]","")
```
</details>

#### Day 5 Solution part 2

- **Answer**: VLCWHTDSZ
- **Timing**: 0.0008361339569091797

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 5 part 2
Solved by doing some magic
"""
import time
import sys
import pandas as pd


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.readlines()
	instructions = [line.strip() for line in entries if 'move' in line]
	above_instructions = [line for line in entries if 'move' not in line]
	number_cols = max(int(num) for num in above_instructions[-2].split())  # get how many cols there are supposed to be
	crates = above_instructions[:-2]  # last items is a newline and numbers row so we remove
	data = []
	for line in crates:
		line = line.replace("    ", "\n").replace("\n", " ").split(" ")  # elf style parsing. dont ask.
		items = line[:-1] if not line[-1] else line  # strips out lines that end in blanks
		data.append(items)
	df = pd.DataFrame(columns=[str(num + 1) for num in range(number_cols)], data=data)
	final_arr = [[val for val in a if val] for a in [df[col].tolist() for col in df.columns]]

	for instruction in instructions:
		# remove loop and grab len(num_to_move) from array instead
		action, number_to_move, from_col, from_col_num, to_col, to_col_num = instruction.split()  # <-- lol
		from_col_num = int(from_col_num)
		number_to_move = int(number_to_move)
		to_col_num = int(to_col_num)
		arr_value_move = final_arr[from_col_num - 1][:int(number_to_move)]
		# update the array with removed value
		final_arr[from_col_num - 1] = final_arr[from_col_num - 1][int(number_to_move):]
		# update the new array
		final_arr[to_col_num - 1] = arr_value_move + final_arr[to_col_num - 1]
	return "".join(arr[0] for arr in final_arr).replace("[","").replace("]","")
```
</details>

<hr>

### üéÑ Day 4

#### Day 4 Solution part 1

- **Answer**: 518
- **Timing**: 0.00203704833984375

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 4 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	# Parsing
	entries = [line.split(",") for line in entries.strip().splitlines()]
	sol = 0
	for entry in entries:
		# more parsing...
		elf1, elf2 = [list(map(int, e.split("-"))) for e in entry]  # must be better way doing this??
		# create ranges for each section with adding 1 to account for 0 based
		elf1_range = set(range(elf1[0], elf1[1] + 1))
		elf2_range = set(range(elf2[0], elf2[1] + 1))
		# check both cases of full ranges being in either elves sections.
		if set.issubset(elf2_range, elf1_range):
			sol += 1
		elif set.issubset(elf1_range, elf2_range):
			sol += 1
	return sol
```
</details>

#### Day 4 Solution part 2

- **Answer**: 909
- **Timing**: 0.002276897430419922

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 4 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
	with open(input_file,'r') as file:
		entries = file.read()
	# Parsing
	entries = [line.split(",") for line in entries.strip().splitlines()]
	sol = 0
	for entry in entries:
		# more parsing...
		elf1, elf2 = [list(map(int, e.split("-"))) for e in entry]  # must be better way doing this??
		# create ranges for each section with adding 1 to account for 0 based
		elf1_range = set(range(elf1[0], elf1[1] + 1))
		elf2_range = set(range(elf2[0], elf2[1] + 1))
		# check both cases of full ranges being in either elves sections.
		if set.intersection(elf2_range, elf1_range):
			sol += 1
		elif set.intersection(elf1_range, elf2_range):
			sol += 1
	return sol
```
</details>

<hr>

### ü¶å Day 3

#### Day 3 Solution part 1

- **Answer**: 7917
- **Timing**: 0.0003268718719482422

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 3 part 1
Solved by doing some magic
"""
import time
import sys
import string

alphabet = string.ascii_lowercase
alpha_dic = {char: i for i, char in enumerate(alphabet + alphabet.upper(), 1)}


def solution(input_file):
    return sum(
        alpha_dic[
            set(line[: len(line) // 2])
            .intersection(line[len(line) // 2 :])
            .pop()
        ]
        for line in [
            line.strip() for line in open(input_file, 'r').readlines()
        ]
    )
```
</details>

#### Day 3 Solution part 2

- **Answer**: 2585
- **Timing**: 0.0005800724029541016

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 3 part 1
Solved by doing some magic
"""
import time
import sys
import string

alphabet = string.ascii_lowercase
alpha_dic = {char: i for i, char in enumerate(alphabet + alphabet.upper(), 1)}


def solution(input_file):
    with open(input_file, 'r') as file:
        groups = []
        current_group = []
        # create elf groups
        for line in [line.strip() for line in file.readlines()]:
            current_group.append(set(list(line)))
            if len(current_group) == 3:
                groups.append(current_group)
                current_group = []
    return sum(alpha_dic[set.intersection(*group).pop()] for group in groups)
```
</details>

<hr>

### üéÅ Day 2

#### Day 2 Solution part 1

- **Answer**: 14531
- **Timing**: 0.0006551742553710938

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 2 part 1
Solved by doing some magic
"""
import time
import sys
import numpy as np
from collections import Counter
import re


# easier to think of who wins in if/else block this way, not actually needed
mapping = {"A": "rock", "X": "rock", "B": "paper", "Y": "paper", "C": "scissors", "Z": "scissors"}

points = {"rock": 1, "paper": 2, "scissors": 3}


def solution(input_file):
    with open(input_file, 'r') as file:
        data = file.readlines()
        score = 0
        for line in data:
            # parsing
            line = line.strip().split(" ")
            player1, player2 = line
            player_1_choice, player_2_choice = mapping[player1], mapping[player2]
            if player_1_choice == player_2_choice:
                # draw case
                score += points[player_1_choice] + 3  # can choose any choice since the same
            # lose case
            elif player_1_choice == "rock" and player_2_choice == "scissors":
                score += points[player_2_choice]
            elif player_1_choice == "paper" and player_2_choice == "rock":
                score += points[player_2_choice]
            elif player_1_choice == "scissors" and player_2_choice == "paper":
                score += points[player_2_choice]
            else:
                # we won!
                score += points[player_2_choice] + 6
    return score
```
</details>

#### Day 2 Solution part 2

- **Answer**: 11258
- **Timing**: 0.0009310245513916016

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 2 part 2
Solved by doing some magic
"""
import time
import sys

# easier to think of who wins in if/else block this way, not actually needed
mapping = {"A": "rock", "B": "paper", "C": "scissors"}

# key is the choice. Value is array of outcomes based on desired scenario.
# First choice is win, second is loss, third is draw
grid = {
    "rock": ["paper", "scissors", "rock"],
    "paper": ["scissors", "rock", "paper"],
    "scissors": ["rock", "paper", "scissors"],
}

points = {"rock": 1, "paper": 2, "scissors": 3}


def solution(input_file):
    with open(input_file, 'r') as file:
        data = [line.strip().split(" ") for line in file.readlines()]
        score = 0
        for line in data:
            # parsing
            player1, player2 = line
            player_1_choice = mapping[player1]
            if player2 == "X":
                # we lose!
                player_2_choice = grid[player_1_choice][1]
                score += points[player_2_choice]
            elif player2 == "Y":
                # we draw!
                score += points[player_1_choice] + 3  # can choose any choice since the same
            else:
                # we win!
                player_2_choice = grid[player_1_choice][0]
                score += points[player_2_choice] + 6
    return score
```
</details>

<hr>

### ‚õÑ Day 1

#### Day 1 Solution part 1

- **Answer**: 68292
- **Timing**: 0.0006909370422363281

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 1 part 1
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
    elf_calories = {}
    with open(input_file, 'r') as file:
        data = file.read().split("\n")
        current_elf = 1
        for line in data:
            if len(line) == 0:
                current_elf += 1
                continue
            elf_calories[str(current_elf)] = elf_calories.get(str(current_elf), 0) + int(line)
    return max(elf_calories.values())
```
</details>

#### Day 1 Solution part 2

- **Answer**: 203203
- **Timing**: 0.0007097721099853516

<details>
<summary>View code</summary>

```python
"""
Solution to Advent of Code 2022 day 1 part 2
Solved by doing some magic
"""
import time
import sys


def solution(input_file):
    elf_calories = {}
    with open(input_file, 'r') as file:
        data = file.read().split("\n")
        current_elf = 1
        for line in data:
            if len(line) == 0:
                current_elf += 1
                continue
            elf_calories[str(current_elf)] = elf_calories.get(str(current_elf), 0) + int(line)
    return sum(sorted(elf_calories.values(), reverse=True)[:3])
```
</details>

<hr>